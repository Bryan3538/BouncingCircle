package com.bfulton.pong;


import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.util.Random;
import javax.swing.SwingWorker;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Bryan Fulton
 */
public class BouncePanel extends javax.swing.JPanel
        implements MouseMotionListener {

    private BouncingCircle bouncer;
    private Paddle paddleOne;
    private Paddle paddleTwo;
    private CircleMoveWorker mover;
    private AIPaddleMoveWorker ai;
    private int playerOnePoints;
    private int playerTwoPoints;
    private boolean running;
    private boolean paused;

    /**
     * Creates new form BouncePanel
     */
    public BouncePanel() {
        int width = 800;
        int height = 600;
        initComponents();
        addMouseMotionListener(this);
        setMinimumSize(new Dimension(width, height));
        setPreferredSize(new Dimension(width, height));
        setBackground(Color.BLACK);
        
        bouncer = new BouncingCircle(20, 20, 30, Color.WHITE);
        paddleOne = new Paddle();
        paddleOne.registerParentContainer(this);
        paddleTwo = new Paddle();
        paddleTwo.registerParentContainer(this);
        paddleTwo.setX(width - paddleTwo.getBounds().width - 5);
        playerOnePoints = 0;
        playerTwoPoints = 0;
        running = false;
        paused = false;
    }

    public synchronized void initiateSession() {
        centerCircle();
        //worker = new CircleMoveWorker();
        //worker.execute();
    }

    public synchronized void startGame() {

        if (!running && !paused) {
            playerOnePoints = 0;
            playerTwoPoints = 0;
        }

        if (!running || paused) {
            mover = new CircleMoveWorker();
            mover.execute();
            ai = new AIPaddleMoveWorker();
            ai.execute();
            running = true;
        }
    }
    
    void stopGame() {
        running = false;
        paused = false;
        mover.cancel(true);
        ai.cancel(true);
        centerCircle();
    }
    
    void togglePause() {
        if(!paused && running) {
            paused = true;
            mover.cancel(true);
            ai.cancel(true);
        } else if (paused && running) {
            startGame();
            paused = false;
        }
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        bouncer.paint(g);
        paddleOne.paint(g);
        paddleTwo.paint(g);

        //draw scores
        int fontsize = 70;
        g.setFont(new Font("Monospace", Font.BOLD, fontsize));
        //paint player 1 score
        g.drawString(Integer.toString(playerOnePoints),
                (int) (this.getWidth() * .25 - fontsize / 2), fontsize);
        //paoint player 2 score
        g.drawString(Integer.toString(playerTwoPoints),
                (int) (this.getWidth() * .75 - fontsize / 2), fontsize);

        //draw center line
        Graphics2D g2 = (Graphics2D) g;
        float dash[] = {55};
        BasicStroke dashed =
                new BasicStroke(3,
                BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER,
                10f, dash, 0f);
        g2.setStroke(dashed);
        int center = (int) (this.getWidth() / 2);
        g2.drawLine(center, 0, center, this.getHeight());   
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        bouncer.paint(g);
        paddleOne.paint(g);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public void mouseMoved(MouseEvent e) {
        paddleOne.setY(e.getY());
        repaint();
    }

    @Override
    public void mouseDragged(MouseEvent me) {
        //don't really need this one
    }

    private void centerCircle() {
        int centerX;
        int centerY;
        Rectangle bounds = getBounds();

        centerX = this.getWidth() / 2 - bouncer.getDiameter() / 2;
        centerY = this.getHeight() / 2 - bouncer.getDiameter() / 2;

        assert (centerX >= 0 && centerY >= 0);

        bouncer.setCoordinates(centerX, centerY);
        repaint();
    }

    

    

    private class CircleMoveWorker extends SwingWorker<Void, Void> {

        @Override
        protected Void doInBackground() throws Exception {
            Rectangle panelBounds = getBounds();

            while (running) {
                bouncer.move();
                //DEBUG
                Rectangle bouncerBounds = bouncer.getBounds();
                Rectangle paddleOneBounds = paddleOne.getBounds();
                Rectangle paddleTwoBounds = paddleTwo.getBounds();
                //END DEBUG
                
                //if the ball hits paddleOne
                if ((bouncer.getX() <= paddleOne.getX() + paddleOne.getWidth())
                        && bouncer.getY() >= paddleOne.getY() &&
                        bouncer.getY() + bouncer.getDiameter() <=
                        paddleOne.getY() + paddleOne.getHeight()) {
                    //bouncer.setX(paddleOne.getX() + paddleOne.getWidth() + 1);
                    bouncer.changeDirection(BouncingCircle.LEFT);
                }
                
                //if the ball hits paddleTwo
//                if ((bouncer.getX() + bouncer.getDiameter() >= paddleTwo.getX())
//                        && bouncer.getY() >= paddleTwo.getY() &&
//                        bouncer.getY() + bouncer.getDiameter() <=
//                        paddleOne.getY() + paddleTwo.getHeight() ) {
//                    //bouncer.setX(paddleTwo.getX() - bouncer.getDiameter() - 1);
//                    bouncer.changeDirection(BouncingCircle.RIGHT);
//                }
                if (bouncer.getBounds().intersects(paddleTwo.getBounds())) {
                    //bouncer.changeDirection(getBounds());
                    bouncer.setX(paddleTwo.getX() - bouncer.getDiameter() - 1);
                    bouncer.changeDirection(BouncingCircle.RIGHT);
                }
                
                //if the ball hits the left wall
                if (bouncer.getX() <= panelBounds.x ) {
                    playerTwoPoints++;
                    bouncer.changeDirection(BouncingCircle.LEFT);
                }
                
                //if the ball hits the right wall
                if(bouncer.getX() + bouncer.getDiameter() >= panelBounds.x + panelBounds.width) {
                    playerOnePoints++;
                    bouncer.changeDirection(BouncingCircle.RIGHT);
                }
                    
                //if the ball hits the bottom
                if (bouncer.getY() + bouncer.getDiameter() >= panelBounds.y + panelBounds.height) {
                    bouncer.changeDirection(BouncingCircle.BOTTOM);
                }
                
                if(bouncer.getY() <= panelBounds.y) {
                    bouncer.changeDirection(BouncingCircle.TOP);
                }
                    
                
                
                repaint();

                try {
                    Thread.sleep(16); //SHOULD BE 16
                } catch (InterruptedException ex) {
                    return null;
                }
            }
            
            return null;
        }
    }
    
    private class AIPaddleMoveWorker extends SwingWorker<Void, Void>
    {
        private final static int MOVE_AMOUNT_MIN = 1;
        private final static int MOVE_AMOUNT_MAX = 13;
        @Override
        protected Void doInBackground() throws Exception {
            Random rng = new Random(System.currentTimeMillis());
            int moveAmount;
            Rectangle paddleBounds;
            Rectangle bouncerBounds;

            while(running)
            {
                moveAmount = rng.nextInt(MOVE_AMOUNT_MAX - MOVE_AMOUNT_MIN + 1) + MOVE_AMOUNT_MIN; 
                paddleBounds = paddleTwo.getBounds();
                bouncerBounds = bouncer.getBounds();
                
                if(bouncerBounds.y < paddleBounds.y)
                {
                    paddleTwo.setY(paddleTwo.getY() - moveAmount);
                }
                else if (bouncerBounds.y + bouncerBounds.height > 
                        paddleBounds.y + paddleBounds.height) {
                    paddleTwo.setY(paddleTwo.getY() + moveAmount);
                }
                
                
                try {
                    Thread.sleep(16); //SHOULD BE 16!
                } catch (InterruptedException ex) {
                    return null;
                }
            }
            
            return null;
        }
        
    }
}
